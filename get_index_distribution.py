import pandas as pd
import numpy as np
import sys

pd.set_option('display.max_columns', None)
pd.set_option('display.width', 200)

"""
T.J.Bl√§tte
2019
"""

"""
To count the number of reads mapped to each sequencing index
combination, as inspired by the Illumina white paper on
index hopping. Indices used by default are the Illumina 
i5 and i7 indices, but custom lists can be supplied by
setting READ_CORRECT_INDICES_FROM_FILE to `True` and 
passing respective index files (2!) as the first two
arguments to the script, followed by the FASTQ files
which contain the index sequences to be counted.

Recommendation: Supply all of the index FASTQ files
generated by a given run together, including the
`Undetermined_*fastq`.

Args:
    A list of paired index FASTQ files (*_I*.fastq)
    containing the index sequences which are to be
    quantified.

Output:
    All output is sent to stdout:
        - The absolute number of reads mapped to each index
          combination, for each sample / pair of index FASTQ files
        - The percent of each sample's index reads
          mapped to each combination
        - The absolute number of reads mapped to each index
          combination, for all samples supplied
        - The percent of reads mapped to each index combination,
          for all samples supplied
"""


def read_and_quantify_fastqs(index_fastqs, correct_indices):
    """
    Read in index FASTQ files and quantify the number of reads
    mapped to each combination of valid indices.

    Args:
        index_fastqs ([(str, str)]): List of tuples, with one tuple
            for each of the two paired index FASTQ filenames
            to be processed.
        correct_indices ([[str], [str]]): List of two lists,
            one for each list of vendor-supplied index sequences
            which are to be quantified.
    """
    correct_indices1, correct_indices2 = correct_indices
    full_index_combinations = pd.DataFrame( np.zeros(
            (len(correct_indices1), len(correct_indices2))),
            columns = correct_indices2,
            index = correct_indices1)
    other_indices = 0
    prnt_msg = "\nIndex combinations that will be counted:\n{}"
    print(prnt_msg.format(full_index_combinations))

    for index_files in index_fastqs:
        print("\nProcessing: {}".format(index_files))
        index_file1, index_file2 = index_files
        index_combinations = pd.DataFrame( np.zeros(
                (len(correct_indices1), len(correct_indices2))),
                columns = correct_indices2,
                index = correct_indices1)

        with open(index_file1, "r") as (fastq1
                ), open(index_file2, "r") as fastq2:
            next_header1 = fastq1.readline()
            while(next_header1):
                headers = [next_header1, fastq2.readline()]
                indices = [fastq.readline().strip("\n") 
                            for fastq 
                            in (fastq1, fastq2)]
                indices = [correct_index(index, resp_correct_indices) 
                            for index, resp_correct_indices 
                            in zip(indices, correct_indices)]
                descriptors_and_bqs = [(fastq.readline(), fastq.readline()) 
                            for fastq 
                            in (fastq1, fastq2)]
                
                if not None in indices:
                    index_combinations.loc[indices[0], indices[1]] += 1
                else:
                    other_indices += 1
                next_header1 = fastq1.readline()
        prnt_msg = "Number of reads per index combination found:\n{}"
        print(prnt_msg.format(index_combinations.astype(int)))
        prnt_msg = "Percent of reads per index combination found:\n{}"
        print(prnt_msg.format(normalize(index_combinations)))
        prnt_msg = ("Number of indices that could not be mapped " +
                    "to any proper index combination: {}")
        print(prnt_msg.format(other_indices))
        full_index_combinations += index_combinations
    prnt_msg = ("\n----\nTotal number of indices that could not be mapped " +
                "to any proper index combination: {}")
    print(prnt_msg.format(other_indices))
    return full_index_combinations

def normalize(matrix):
    """
    Convert numpy array containing absolute numbers into an array
    of percent values, relative to the total number of values in
    the array and rounded to two decimal digits.

    Args:
        matrix (np.array): Array to be normalized.

    Returns:
        matrix (np.array): Normalized array.
    """
    matrix = matrix / matrix.sum().sum() * 100
    matrix = np.round(matrix, 2)
    return matrix

def read_list(filename):
    """
    Read a given file into a list, where each line becomes
    another element. Intended for simple lists of words / strings
    to be read in, such as vendor-supplied index sequences to
    be quantified.

    Args:
        filename (str): Name of the file to be read in.

    Returns:
        List of lines ([str]) with the input file's content.
    """
    with open(filename, "r") as file_:
        all_lines = file_.read().splitlines()
    return all_lines

def correct_index(index, correct_indices, max_distance=1):
    """
    Find the sequencing-error corrected index sequence,
    i.e. for a given index read that was sequenced, find the i5 or i7 
    index sequence provided by Illumina that deviates from this read
    with a certain maximum Hamming distance.

    Args:
        index (str): Index read sequence that is to be error-corrected.
        correct_indices ([str]): List of proper index sequences, 
            provided by the vendor (Illumina).
        max_distance (int): The maximum number of mismatching characters
            between index and one of correct_indices, i.e. the
            maximum Hamming distance that will still allow index
            to be mapped to one of correct_indices.

    Returns:
        The matching correct_index (str) out of correct_indices,
        if one exists with a maximum Hamming distance of max_distance.
    """
    for correct_index in correct_indices:
        if hamming_distance(index, correct_index) <= max_distance:
            return correct_index

def hamming_distance(seq1, seq2):
    """
    Calculate the Hamming distance between two sequences 
    of the same length. 
    The Hamming distance corresponds to the number of characters
    that differ between these two sequences.

    Args:
        seq1 (str), seq2 (str): Sequences to compare.

    Returns:
        Hamming distance (int) of seq1 and seq2.
    """
    dist = sum([char1 != char2 for char1, char2 in zip(seq1, seq2)])
    return dist



READ_CORRECT_INDICES_FROM_FILE = False
correct_indices = None
index_fastqs = None

if READ_CORRECT_INDICES_FROM_FILE:
    correct_indices = [read_list(filename) for filename in sys.argv[1:3]]
    index_fastqs = sys.argv[3:]
else:
    illumina_i5 = [
            'GCGTAAGA', 
            'CTCTCTAT', 
            'TATCCTCT', 
            'AGAGTAGA', 
            'GTAAGGAG', 
            'ACTGCATA', 
            'AAGGAGTA', 
            'CTAAGCCT']
    illumina_i7 = [
            'TAAGGCGA', 
            'CGTACTAG', 
            'AGGCAGAA', 
            'TCCTGAGC', 
            'GGACTCCT', 
            'TAGGCATG', 
            'CTCTCTAC', 
            'CAGAGAGG', 
            'GCTACGCT', 
            'CGAGGCTG', 
            'AAGAGGCA', 
            'GTAGAGGA']
    correct_indices = [illumina_i7, illumina_i5]
    index_fastqs = sys.argv[1:]


index_fastqs = [(index1_fastq, index2_fastq) 
                for index1_fastq, index2_fastq 
                in zip(index_fastqs[0::2], index_fastqs[1::2])]
prnt_msg = "\nGoing to process the following pairs of Index Fastq files:\n{}"
print(prnt_msg.format(index_fastqs))


indices = read_and_quantify_fastqs(index_fastqs, correct_indices)
prnt_msg = "\nTotal number of reads mapped to each index combination:\n{}"
print(prnt_msg.format(indices.astype(int)))

indices = normalize(indices)
prnt_msg = "\nPercent of total reads mapped to each index combination:\n{}"
print(prnt_msg.format(indices))




